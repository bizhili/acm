/**
  ****************************(C) COPYRIGHT 2020 CCZU****************************
  * @file       uartTask.c/h
  * @brief      串口2与串口8任务，串口2用于上位机调试，支持printf函数，串口8用于与TX2通信，CRC16检验，
  *             DMA初始化，通信协议书写
  * @note       head+data+tail：
                head=0XAA,0X55
                data
                tail:CRC16 data
  * @history
  *  Version    Date            Author          Modification
  *  V1.0.0     2020/1/9        BIZHI              测试中
  *
  @verbatim
  ==============================================================================

  ==============================================================================
  @endverbatim
  ****************************(C) COPYRIGHT 2020 CCZU****************************
  */
#include "uartTask.h"
#include "include.h"

/**************************************
@功能            将stm32数据转换为发送数据
@调用关系        调用Append_CRC16_Check_Sum(SendBuffer,15)生成CRC16校验码
@输入参数              无
@返回值                无
@说明                  无
***************************************/
void transferToBuffer(void);
/**************************************
@功能            将接收数据转化为stm32数据
@调用关系           
@输入参数               无
@返回值                无
@说明            
***************************************/
void transferToMydata(void);
static const RC_ctrl_t *shoot_rc2;
static const motor_measure_t *gimbal_yaw_motor,*gimbal_pitch_motor,*gimbal1,*gimbal2,*gimbal3,*gimbal4;
static messege mes1;
messegeTx2 TX2messege;
union u16Tou8 u162u8;
union u16Tofloat u162float;

int fputc(int ch, FILE *f)
{
	while (DMA_GetCmdStatus(DMA1_Stream6) != DISABLE);       //确保DMA可以被设置
  SendBuffer2[0]=(unsigned char)ch;
  Dma_Send_Enable2(DMA1_Stream6,1);
	return ch;
}

static getss get1;
void uartTask(void *pvParameters)
{
  Init_Usart6(115200);
  Init_Usart2(115200);
  Init_Dma_Tx_Config(USART6, (u32)(&USART6->DR), DMA2_Stream7, DMA_Channel_5, (u32)SendBuffer, BufferLen, DMA2_Stream7_IRQn);
  //DMA 接收数据流初始化
  Init_Dma_Rx_Config(USART6, (u32)(&USART6->DR), DMA2_Stream2, DMA_Channel_5, (u32)ReceiveBuffer, BufferLen);
  
  Init_Dma_Tx_Config2(USART2, (u32)(&USART2->DR), DMA1_Stream6, DMA_Channel_4, (u32)SendBuffer2, BufferLen, DMA1_Stream6_IRQn);
  //DMA 接收数据流初始化
  Init_Dma_Rx_Config2(USART2, (u32)(&USART2->DR), DMA1_Stream5, DMA_Channel_4, (u32)ReceiveBuffer2, BufferLen);
  while(1)
  {
    //接收到一帧数据
    CAN_CMD_CHASSIS2(1000,1000,1000,1000);
    TX2messege.send.time=TX2messege.receive.time;
    static u16 power=0;
    gimbal1=get_Chassis_Motor_Measure_Point(0x201);
    gimbal2=get_Chassis_Motor_Measure_Point(0x202);
    gimbal3=get_Chassis_Motor_Measure_Point(0x203);
    gimbal4=get_Chassis_Motor_Measure_Point(0x204);
    power=fabs(gimbal1->given_current)+fabs(gimbal2->given_current)+fabs(gimbal3->given_current)+fabs(gimbal4->given_current);
    mes1.power=power;
    gimbal_pitch_motor=get_Pitch_Gimbal_Motor_Measure_Point(); 
    gimbal_yaw_motor=get_Yaw_Gimbal_Motor_Measure_Point();
    p
    vTaskDelay(uartDelayTime*2);
  }
}

void transferToMydata(void)
{
  TX2messege.receive.tx2Statu=ReceiveBuffer[2];
  TX2messege.receive.fps=ReceiveBuffer[3];
  TX2messege.receive.time=ReceiveBuffer[4];
  u162u8.u8data[0]=ReceiveBuffer[5];
  u162u8.u8data[1]=ReceiveBuffer[6];
  TX2messege.receive.distance=u162u8.u16data;
  u162float.u8data[0]=ReceiveBuffer[7];
  u162float.u8data[0]=ReceiveBuffer[8];
  u162float.u8data[0]=ReceiveBuffer[9];
  u162float.u8data[0]=ReceiveBuffer[10];
  TX2messege.receive.pitchAngle=u162float.fdata;
  u162float.u8data[0]=ReceiveBuffer[11];
  u162float.u8data[0]=ReceiveBuffer[12];
  u162float.u8data[0]=ReceiveBuffer[13];
  u162float.u8data[0]=ReceiveBuffer[14];
  TX2messege.receive.pitchAngle=u162float.fdata;
}
void transferToBuffer(void)
{
  //head bytes
  SendBuffer[0]=0XAA;
  SendBuffer[1]=0X55;
  //control bytes
  SendBuffer[2]=TX2messege.send.control;
  //ID bytes
  SendBuffer[3]=TX2messege.send.roboID;
  //time bytes
  SendBuffer[4]=TX2messege.send.time;
  //motorspeed bytes
  u162float.fdata=TX2messege.send.yawMotorSpeed;
  SendBuffer[5]=u162float.u8data[0];
  SendBuffer[6]=u162float.u8data[1];
  SendBuffer[7]=u162float.u8data[2];
  SendBuffer[8]=u162float.u8data[3];
  //absolutespeed bytes
  u162float.fdata=TX2messege.send.yawAbsoluteSpeed;
  SendBuffer[9]=u162float.u8data[0];
  SendBuffer[10]=u162float.u8data[1];
  SendBuffer[11]=u162float.u8data[2];
  SendBuffer[12]=u162float.u8data[3];
  //CRC16 bytes:
  Append_CRC16_Check_Sum(SendBuffer,15);
}

messege *getReceviedU6(void)
{
  return &mes1;
}

const getss *get_res(void)
{
  return &get1;
}



//void USART6_IRQHandler(void)			   //串口6全局中断服务函数//used to chat with TX2
//{
//  static u8 head,tail;
//  static u16 whole;
//	if(USART_GetITStatus(USART6, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
//  {
//  get1.res6=USART6->DR;
//  if(get1.res6>=64)
//  {
//    head=get1.res6-64;
//    mes1.received.flag=2;
//  }
//  else if(get1.res6<64&&mes1.received.flag==2)
//  {
//    tail=get1.res6;
//    whole=head*64+tail;
//    if(whole<330&&whole>0)
//    {
//      mes1.received.axis.y=((whole-165)/7.5+4.9)*8191/360;
//      mes1.received.flag=1;
//    }
//    else if(whole<830&&whole>0)
//    {
//      mes1.received.axis.x=(whole-218-218-165+30)/7.5;
//      mes1.received.flag=1;
//      
//    }
//    
//  }

//  
//  }
//}





